# -*- coding: utf-8 -*-
"""Correlation_analysis_nutrional_attributes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NaGpSChzTmfasx3h4gfhMACDWwmnQ3sq
"""

import pandas as pd
import numpy as np
import os

# Anterior and Posterior Teeth as defined by American Dental Association
# https://radiopaedia.org/articles/american-dental-association-universal-numbering-system?lang=us

ANTERIOR = list(range(6, 12)) + list(range(22, 28))
POSTERIOR = list(range(1, 6)) + list(range(12, 22)) + list(range(28, 33))
ALL_TEETH = ANTERIOR + POSTERIOR

# Some codings for easier usage later
CODINGS = {
    'ABSENT': 0,
    'PRESENT': 1,

}


def get_data(url='https://wwwn.cdc.gov/Nchs/Nhanes/2017-2018/P_OHXDEN.XPT', path='./dataset/P_OHXDEN.XPT'):
    """
    Load data from path if exists, else pull from url
    @param url: URL of the data
    @type url: str
    @param path: Path of dataset on file system if exists
    @type path: str
    @return: Entire pd.DataFrame
    """
    return pd.read_sas(path if os.path.exists(path) else url)


# OHXxxTC Column Description :
# Code  Description	                            Count	Cumulative  Convert Explanation
# 1	    Primary tooth (deciduous) present	    0	    0           1       Present
# 2	    Permanent tooth present	                7534	7534        1       Present
# 3	    Dental implant	                        4	    7538        0       Absent
# 4	    Tooth not present	                    5609	13147       0       Absent
# 5	    Permanent dental root fragment present	131	    13278       0       Absent
# 9	    Could not assess	                    0	    13278       0       Treat as Absent
# .	    Missing	                                494	    13772       0       Treat as Absent


TOOTH_COUNT_CODINGS = {
    1: 1,  # Primary tooth
    2: 1,  # Perm tooth
    3: 0,  # Implant
    4: 0,
    5: 0,
    9: 0,
    'nan': np.nan
}


def get_tc_col_name(t):
    '''
    Get Col Name in data
    @param t: Tooth Number
    @return: Col Name
    '''
    return 'OHX{tooth:02d}TC'.format(tooth=t)


def get_tooth_count(df, tooth_list, codings=None, skipna=True):
    """
    Gets tooth count from merging TOOTH_COUNT cols for all teeth in tooth_list
    @param codings:
    @param df: DataFrame
    @type df: pd.DataFrame
    @param tooth_list: ANTERIOR or POSTERIOR
    @return: pd.Series of Tooth Count
    """
    if codings is None:
        codings = TOOTH_COUNT_CODINGS
    cols = list(map(get_tc_col_name, tooth_list))
    data = df[cols]
    return data.applymap(lambda x: codings['nan'] if np.isnan(x) else codings[x]).sum(axis=1, skipna=skipna)


#
# Caries
# Code 	Description	                                                            Count	Cumulative  Convert
# A	    Primary tooth with a restored surface condition	                        0	    0           1
# D	    Sound primary tooth	                                                    0	    0           0
# E	    Missing due to dental disease	                                        1197	1197        1
# F	    Permanent tooth with a restored surface condition	                    2908	4105        1
# J	    Permanent root tip is present but no restorative replacement is present	131	    4236        1
# K	    Primary tooth with a dental carious surface condition	                0	    4236        1
# M	    Missing due to other causes	                                            47	    4283        1
# P	    Missing due to dental disease but replaced by a removable restoration	1019	5302        1
# Q	    Missing due to other causes but replaced by a removable restoration	    37	    5339        1
# R	    Missing due to dental disease but replaced by a fixed restoration	    13	    5352        1
# S	    Sound permanent tooth	                                                4394    9746        0
# T	    Permanent root tip is present but a restorative replacement is present	0	    9746        1
# U	    Unerupted	                                                            3297	13043       nan
# X	    Missing due to other causes but replaced by a fixed restoration	        0	    13043       nan
# Y	    Tooth present, condition cannot be assessed	                            11	    13054       nan
# Z	    Permanent tooth with a dental carious surface condition	                220	    13274       1
# nan	Missing	                                                                498	    13772       nan

CARIES_CODINGS = {
    'A': 1,
    'D': 0,
    'E': 3,
    'F': 1,
    'J': 3,
    'K': 2,
    'M': 3,
    'P': 3,
    'Q': 3,
    'R': 3,
    'S': 0,
    'T': 3,
    'U': np.nan,
    'X': np.nan,
    'Y': np.nan,
    'Z': 2,
    'nan': np.nan,
    '': np.nan
}

CARIES_CODINGS_01 = {
    'A': 1,
    'D': 0,
    'E': 1,
    'F': 1,
    'J': 1,
    'K': 1,
    'M': 1,
    'P': 1,
    'Q': 1,
    'R': 1,
    'S': 0,
    'T': 1,
    'U': np.nan,
    'X': np.nan,
    'Y': np.nan,
    'Z': 1,
    'nan': np.nan,
    '': np.nan
}


def get_tooth_caries_col_name(t):
    '''
    Get Caries Col Name in Dataset
    @param t: Tooth Number
    @return: Col name
    '''
    return 'OHX{tooth:02d}CTC'.format(tooth=t)


def del_not_present_cols(l, np):
    l1 = l.copy()
    for x in np:
        if x in l1:
            del l1[l1.index(x)]
    return l1


def get_caries_count(df, tooth_list, codings=None, usage='01', skipna=True):
    """
    Gets tooth count from merging TOOTH_COUNT cols for all teeth in tooth_list
    @param usage: 01 for 01 data
    @param codings:
    @param df: DataFrame
    @type df: pd.DataFrame
    @param tooth_list: ANTERIOR or POSTERIOR
    @return: pd.Series of Tooth Count
    """
    if codings is None:
        codings = CARIES_CODINGS
    if usage == '01':
        codings = CARIES_CODINGS_01
    # No Caries Col for 1,32
    tl = del_not_present_cols(tooth_list, [1, 16, 17, 32])

    cols = list(map(get_tooth_caries_col_name, tl))
    data = df[cols]
    return data.applymap(lambda x: codings[x.decode()]).sum(axis=1, skipna=skipna)


#  Dental Sealants Data Description
#
# Code  Description	                                    Count	Cumulative	Convert
# 0	    Sealant not present	                            4194	4194	    0
# 1	    Occlusal sealant on permanent tooth	            102 	4296	    1
# 2	    Facial sealant on permanent tooth	            0	    4296	    1
# 3	    Lingual sealant on permanent tooth	            0	    4296	    1
# 4	    Occlusal sealant on primary tooth	            51	    4347	    1
# 9	    Cannot be assessed	                            41	    4388	    nan
# 12	Occlusal-facial sealant on permanent tooth	    0	    4388	    1
# 13	Occlusal-lingual sealant on permanent tooth	    0	    4388	    1
# nan	Missing	                                        9384	13772       nan

SEALANT_CODINGS = {
    0: 0,
    1: 1,
    2: 1,
    3: 1,
    4: 1,
    9: np.nan,
    12: 1,
    13: 1,
    'nan': np.nan,
    '': np.nan
}


def get_sealant_col_name(t):
    '''
    Get Sealant Col Name in Datset
    @param t: Tooth Number
    @return: Col Name
    '''
    return 'OHX{tooth:02d}SE'.format(tooth=t)


def get_sealant_count(df, tooth_list, codings=None, skipna=True):
    """
    Gets tooth count from merging TOOTH_COUNT cols for all teeth in tooth_list
    @param codings:
    @param df: DataFrame
    @type df: pd.DataFrame
    @param tooth_list: ANTERIOR or POSTERIOR
    @return: pd.Series of Tooth Count
    """
    if codings is None:
        codings = SEALANT_CODINGS
    # No Sealant Col for 1,32
    tl = del_not_present_cols(tooth_list, [1, 6, 8, 9, 11, 16, 17, 22, 23, 24, 25, 26, 27, 32])
    cols = list(map(get_sealant_col_name, tl))
    data = df[cols]
    return data.applymap(lambda x: codings[''] if not x.decode() else codings[int(x.decode())]).sum(axis=1,
                                                                                                    skipna=skipna)


#   Root Caries, other lesions X [restored , not] Data Description
# Code Description	            Count   Convert
# 1	    Yes	                    1085    1
# 2	    No	                    6916	0
# 9	    Cannot be accessed	    7		nan
# .	    Missing	                5764	nan

ROOT_CODINGS = {
    1: 1,
    2: 0,
    9: np.nan,
    'nan': np.nan
}


def get_root_caries(df, codings=None, skipna=True):
    '''
    Sum Root Caries and Root caries Restorartion
    @param df: Dataset
    @param codings: Converion Matrix
    @param skipna: How to treat NA values
    @return: pd.Series
    '''
    if codings is None:
        codings = ROOT_CODINGS
    data = df[['OHXRCAR', 'OHXRRES']]
    return data.applymap(lambda x: codings['nan'] if np.isnan(x) else codings[x]).sum(axis=1, skipna=skipna)


def get_other_non_carious_restoration(df, codings=None, skipna=True):
    '''
    Sum Other Caries and Other Restorartions
    @param df: Dataset
    @param codings: Converion Matrix
    @param skipna: How to treat NA values
    @return: pd.Series
    '''
    if codings is None:
        codings = ROOT_CODINGS
    data = df[['OHXRCARO', 'OHXRRESO']]
    return data.applymap(lambda x: codings['nan'] if np.isnan(x) else codings[x]).sum(axis=1, skipna=skipna)


def preprocess_dental_data(usage='', set_index=False, skipna=True, drop_all_na=False, drop_any_na=False):
    '''
    Pre Process the Dental Health Data
    @param usage: '01' if using for modelling
    @param set_index: Whether or not to set the SEQN col as index
    @param skipna: How to treat the NA values
    @param drop_all_na: Drop rows with all na values
    @param drop_any_na: Drop rows with any value as na
    @return: pd.DataFrame
    '''
    df = get_data()
    data = pd.DataFrame(df['SEQN'])
    data['ANTERIOR_TOOTH_COUNT'] = get_tooth_count(df, ANTERIOR, skipna=skipna)
    data['POSTERIOR_TOOTH_COUNT'] = get_tooth_count(df, POSTERIOR, skipna=skipna)
    data['TOTAL_TOOTH_COUNT'] = get_tooth_count(df, ALL_TEETH, skipna=skipna)
    data['ANTERIOR_CARIES_COUNT'] = get_caries_count(df, ANTERIOR, usage=usage, skipna=skipna)
    data['POSTERIOR_CARIES_COUNT'] = get_caries_count(df, POSTERIOR, usage=usage, skipna=skipna)
    data['TOTAL_CARIES_COUNT'] = get_caries_count(df, ALL_TEETH, usage=usage, skipna=skipna)
    data['ANTERIOR_DENTAL_SEALANT_COUNT'] = get_sealant_count(df, ANTERIOR, skipna=skipna)
    data['POSTERIOR_DENTAL_SEALANT_COUNT'] = get_sealant_count(df, POSTERIOR, skipna=skipna)
    data['TOTAL_SEALANT_COUNT'] = get_sealant_count(df, ALL_TEETH, skipna=skipna)
    data['ROOT_CARIES'] = get_root_caries(df, skipna=skipna)
    data['OTHER_NON_CARIOUS_ROOT_LESION'] = get_other_non_carious_restoration(df, skipna=skipna)
    if drop_all_na:
        data = data.dropna(subset=['ANTERIOR_CARIES_COUNT', 'POSTERIOR_CARIES_COUNT', 'ANTERIOR_DENTAL_SEALANT_COUNT',
                                   'POSTERIOR_DENTAL_SEALANT_COUNT', 'ROOT_CARIES', 'OTHER_NON_CARIOUS_ROOT_LESION'],
                           how='all')
    if drop_any_na:
        data = data.dropna(subset=['ANTERIOR_CARIES_COUNT', 'POSTERIOR_CARIES_COUNT', 'ANTERIOR_DENTAL_SEALANT_COUNT',
                                   'POSTERIOR_DENTAL_SEALANT_COUNT', 'ROOT_CARIES', 'OTHER_NON_CARIOUS_ROOT_LESION'],
                           how='any')
    if set_index:
        data = data.set_index('SEQN')
    data['ANTERIOR_SIMPLE_01'] = data[get_teeth_subset_labels('ANTERIOR')].max(axis=1).\
        map(lambda x: 1 if x > 0 else 0)
    data['POSTERIOR_SIMPLE_01'] = data[get_teeth_subset_labels('POSTERIOR')].max(axis=1).\
        map(lambda x: 1 if x > 0 else 0)
    data['TOTAL_SIMPLE_01'] = data[get_teeth_subset_labels('')].max(axis=1).\
        map(lambda x: 1 if x > 0 else 0)
    data['SERIOUS_01'] = data.apply(get_serious_01_label, axis=1)
    return data


ANTERIOR_LABELS = ['ANTERIOR_CARIES_COUNT', 'ANTERIOR_DENTAL_SEALANT_COUNT']
POSTERIOR_LABELS = ['POSTERIOR_CARIES_COUNT', 'POSTERIOR_DENTAL_SEALANT_COUNT']
ROOT_LABELS = ['ROOT_CARIES', 'OTHER_NON_CARIOUS_ROOT_LESION']


def get_teeth_subset_labels(teeth_subset):
    if teeth_subset == 'ANTERIOR':
        return ANTERIOR_LABELS + ROOT_LABELS
    if teeth_subset == 'POSTERIOR':
        return POSTERIOR_LABELS + ROOT_LABELS
    return ANTERIOR_LABELS + POSTERIOR_LABELS + ROOT_LABELS


def get_serious_01_label(row):
    for col in ['TOTAL_CARIES_COUNT', 'TOTAL_SEALANT_COUNT', 'OTHER_NON_CARIOUS_ROOT_LESION']:
        if (not np.isnan(row[col])) and row[col] >= 6:
            return 1
    col = 'ROOT_CARIES'
    if (not np.isnan(row[col])) and row[col] > 0:
        return 1
    return 0


if __name__ == "__main__":
    # print(get_tooth_count(get_data(), ANTERIOR))
    # print(get_caries_count(get_data(), ANTERIOR))
    # print(get_sealant_count(get_data(), ANTERIOR))
    # print(get_root_caries(get_data()))
    # print(get_other_non_carious_restoration(get_data()))
    df_dental = preprocess_dental_data(usage='01', drop_all_na=True, skipna=False, set_index=True)

import pandas as pd
import numpy as np
import os


def preprocess(
        dietary_url='https://wwwn.cdc.gov/Nchs/Nhanes/2017-2018/P_DSQTOT.XPT',
        nutrition_url='https://wwwn.cdc.gov/Nchs/Nhanes/2017-2018/P_DR1TOT.XPT',
        dental_url='https://wwwn.cdc.gov/Nchs/Nhanes/2017-2018/P_OHXDEN.XPT',
        for_modelling=False):
    '''
    @description: 
        Pre-process the Dietary Supplement, Nutrient Intakes, and Dental Health data
    @param: 
        URLs of the three data
    @return: 
        Pre-processed Pandas DataFrame
    '''
    # please be patient for data download
    dietary_path = './dataset/P_DR1TOT.XPT'
    nutrition_path = './dataset/P_DSQTOT.XPT'
    dental_path = './dataset/P_OHXDEN.XPT'

    df_dietary = pd.read_sas(
        dietary_path if os.path.exists(dietary_path) else dietary_url)
    df_nutrition = pd.read_sas(nutrition_path if os.path.exists(
        nutrition_path) else nutrition_url)
    df_dental = preprocess_dental_data()

    df_data = pd.merge(df_dietary, df_nutrition, on='SEQN')


    # fill the missing precise quantatative or special dietary data with 0
    attrs_set_0 = ['DR1SKY']
    for attr in df_data.columns:
        if attr.startswith('DSQ') or attr.startswith('DRQS') or attr.startswith('DRD'):
            attrs_set_0.append(attr)
    df_data[attrs_set_0] = df_data[attrs_set_0].fillna(0)

    # drop Coronal Caries and Sealants attributes from dental data
    # attrs_keep = []
    # for attr in df_data.columns:
    #     if not (attr.startswith('OHX') and (attr.endswith('CTC') or attr.endswith('CSC')
    #             or attr.endswith('RTC') or attr.endswith('RSC') or attr.endswith('SE'))):
    #         attrs_keep.append(attr)
    # df_data = df_data[attrs_keep]

    # fill missing "dental implant or not?" with "no"
    # df_data.loc[:, 'OHXIMP'].fillna(2, inplace=True)
    # fill missing "how often add salt?" with "don't know"
    df_data.loc[:, 'DBD100'].fillna(9, inplace=True)

    # fill missing "Root Caries, Non-carious Lesion, Root Caries Restoration, Non-carious Lesion Restoration" with "not detected"
    # df_data.update(
    #     df_data[['OHXRCAR', 'OHXRCARO', 'OHXRRES', 'OHXRRESO']].fillna(0))

    # Change 'Refused'/'Don't know'/'Incomplete' to either appropriate value or NaN
    df_data.loc[df_data['WTDRD1PP'] == 0, 'WTDRD1PP'] = np.NaN      # incomplete -> NaN
    df_data.loc[df_data['WTDR2DPP'] == 0, 'WTDR2DPP'] = np.NaN      # incomplete -> NaN
    df_data.loc[df_data['DR1DRSTZ'] == 5, 'DR1DRSTZ'] = 1           # incomplete -> meet minimum criteria
    df_data.loc[df_data['DR1MRESP'] >= 77, 'DR1MRESP'] = np.NaN     # Refused/dont know -> NaN
    df_data.loc[df_data['DR1HELP'] >= 77, 'DR1HELP'] = np.NaN       # Refused/dont know -> NaN
    df_data.loc[df_data['DBQ095Z'] == 99, 'DBQ095Z'] = np.NaN       # Refused/dont know -> NaN
    df_data.loc[df_data['DBD100'] >= 7, 'DBD100'] = np.NaN          # Refused/dont know -> NaN
    df_data.loc[(df_data['DRQSPREP'] == 9) | (df_data['DRQSPREP'] == 0), 'DRQSPREP'] = np.NaN   # Refused/dont know -> NaN
    df_data.loc[df_data['DR1STY'] == 9, 'DR1STY'] = 2               # Refused/dont know -> 2
    df_data.loc[(df_data['DRQSDIET'] == 9) | (df_data['DRQSDIET'] == 0), 'DRQSDIET'] = 2        # Refused/dont know -> 2
    df_data.loc[df_data['DR1_300'] >= 7, 'DR1_300'] = 2             # Refused/dont know -> 2
    df_data.loc[df_data['DR1TWSZ'] == 99, 'DR1TWSZ'] = np.NaN       # Refused/dont know -> NaN

    df_data.loc[df_data['DSDCOUNT'] >= 77, 'DSDCOUNT'] = 0          # Refused/dont know -> 0
    df_data.loc[df_data['DSDANCNT'] >= 77, 'DSDANCNT'] = 0          # Refused/dont know -> 0
    df_data.loc[df_data['DSD010'] >= 7, 'DSD010'] = 2               # Refused/dont know -> 2
    df_data.loc[df_data['DSD010AN'] >= 7, 'DSD010AN'] = 2           # Refused/dont know -> 2

    # Change categorical data to categorical columns
    cat_attrs = [
        'DR1DRSTZ', 'DRABF', 'DRDINT', 'DR1DAY', 'DR1LANG', 'DR1MRESP', 'DR1HELP', 'DBQ095Z',
        'DBD100', 'DRQSPREP', 'DR1STY', 'DR1SKY', 'DRQSDIET', 'DR1_300', 'DR1TWSZ',
        "DSD010", "DSD010AN" # Dietary supplements
    ]

    # fill missing values
    df_data[cat_attrs] = df_data[cat_attrs].fillna(df_data[cat_attrs].mode().iloc[0])
    df_data.fillna(df_data.mean(), inplace = True)
    df_data = df_data.dropna()

    for attr in df_data.columns:
        if attr.startswith('DRQSDT'):
            cat_attrs.append(attr)
    for attr in cat_attrs:
        df_data[attr] = pd.Categorical(df_data[attr])

    # Merge Dental Data at the end
    if not for_modelling:
        df_data = pd.merge(df_data, df_dental, on='SEQN')
    else:
        df_data = df_data.set_index('SEQN')
    return df_data



if __name__ == '__main__':
    df_data = preprocess()

nutritions = []
df_nutritions = pd.concat([df_data.loc[:,"SEQN"], df_data.loc[:,"DSQTIODI":"DRD370V"]], axis = 1)
df_nutritions.info()

import matplotlib.pyplot as plt
import numpy as np
final =[]
total_values1 = (sum(df_nutritions["DR1TMAGN"])+sum(df_nutritions["DR1TCAFF"])+sum(df_nutritions["DR1TFIBE"])+sum(df_nutritions["DR1TSODI"]))*0.001
total_values2 = sum(df_nutritions["DR1TCARB"])+sum(df_nutritions["DR1TPROT"])+sum(df_nutritions["DR1TSUGR"])+sum(df_nutritions["DR1TALCO"])+sum(df_nutritions["DR1TFIBE"])
total_values = total_values1+total_values2
final.append(100*0.001*sum(df_nutritions["DR1TMAGN"])/total_values)
final.append(100*sum(df_nutritions["DR1TCARB"])/total_values)
final.append(100*sum(df_nutritions["DR1TPROT"])/total_values)
final.append(100*0.001*sum(df_nutritions["DR1TCAFF"])/total_values)
final.append(100*sum(df_nutritions["DR1TSUGR"])/total_values)
final.append(100*sum(df_nutritions["DR1TALCO"])/total_values)
final.append(100*0.001*sum(df_nutritions["DR1TSODI"])/total_values)
final.append(100*sum(df_nutritions["DR1TFIBE"])/total_values)
y = np.array(final)
colors_grey = [plt.get_cmap('BrBG')(0.25), 'grey'] + [plt.get_cmap('BrBG')(0.25)] * 7
colors = ["red", colors_grey[0], "black", "#4CAF50","orange","orange","blue","magenta"]
df_continuous_variables_labels_gms = ["Magnesium","Carbohydrate", "protein", "Caffeine","Total sugars","Alcohol","Sodium", "Dietary fiber"]

import matplotlib.pyplot as plt
# The slices will be ordered and plotted counter-clockwise.
labels = [r'Magnesium (0.0597 %)', r'Carbohydrate (54.16 %)', 
r'Protein (16.4 %)', r'Caffeine (0.021%)',r'Total sugar (23.77 %)', r'Alcohol (1.416 %)', r'Sodium (0.72 %)', r'Dietary fiber (3.4 %)']
sizes = [88.4, 10.6, 0.7, 0.3]
colors = ["red", colors_grey[0], "black", "#4CAF50","orange","orange","blue","magenta"]
patches, texts = plt.pie(y, colors=colors, startangle=90)

plt.legend(patches, labels, loc="best") # The Legend

# Set aspect ratio to be equal so that pie is drawn as a circle.
plt.axis('equal')
plt.tight_layout()
plt.show()

#Bar chart for primary nutrients
[a1,b1,c1,a2,b2,c2,c3,a3,a4,b3,a5,a6,a7,b4,b5,b6,b7,c4,c5,c6,c7,d1,d2,d3,d4,d5,d6,d7] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
for index,d in df_nutritions.iterrows():
  if(d["DR1DAY"]==1):
    a1= a1+d["DR1TCARB"]
    b1= b1+d["DR1TPROT"]
    c1= c1+d["DR1TALCO"]
    d1= d1+d["DR1TCAFF"]
  elif(d["DR1DAY"]==2):
    a2= a2+d["DR1TCARB"]
    b2= b2+d["DR1TPROT"]
    c2= c2+d["DR1TALCO"]
    d2= d2+d["DR1TCAFF"]
  elif(d["DR1DAY"]==3):
    a3= a3+d["DR1TCARB"]
    b3= b3+d["DR1TPROT"]
    c3= c3+d["DR1TALCO"]
    d3= c3+d["DR1TCAFF"]
  elif(d["DR1DAY"]==4):
    a4= a4+d["DR1TCARB"]
    b4= b4+d["DR1TPROT"]
    c4= c4+d["DR1TALCO"]
    d4= c4+d["DR1TCAFF"]
  elif(d["DR1DAY"]==5):
    a5= a5+d["DR1TCARB"]
    b5= b5+d["DR1TPROT"]
    c5= c5+d["DR1TALCO"]
    d5= d5+d["DR1TCAFF"]
  elif(d["DR1DAY"]==6):
    a6= a6+d["DR1TCARB"]
    b6= b6+d["DR1TPROT"]
    c6= c6+d["DR1TALCO"]
    d6= d6+d["DR1TCAFF"]

  elif(d["DR1DAY"]==7):
    a7= a7+d["DR1TCARB"]
    b7= b7+d["DR1TPROT"]
    c7= c7+d["DR1TALCO"]
    d7= d7+d["DR1TCAFF"]
Y_carb = [a1/len(df_nutritions),a2/len(df_nutritions),a3/len(df_nutritions),a4/len(df_nutritions),a4/len(df_nutritions),a6/len(df_nutritions),a7/len(df_nutritions)]
Y_protein = [b1/len(df_nutritions),b2/len(df_nutritions),b3/len(df_nutritions),b4/len(df_nutritions),b5/len(df_nutritions),b6/len(df_nutritions),b7/len(df_nutritions)]
Y_alcohol = [c1/len(df_nutritions),c2/len(df_nutritions),c3/len(df_nutritions),c4/len(df_nutritions),c5/len(df_nutritions),c6/len(df_nutritions),c7/len(df_nutritions)]
Y_caffeine = [d1/len(df_nutritions),d2/len(df_nutritions),d3/len(df_nutritions),d4/len(df_nutritions),d5/len(df_nutritions),d6/len(df_nutritions),d7/len(df_nutritions)]
for k in range(len(Y_caffeine)):
 Y_caffeine[k] = Y_caffeine[k]/1000

#computing the percentage increment of friday intake
#method1
Y_carb_avg = sum(Y_carb)/len(Y_carb)
Y_protein_avg = sum(Y_protein)/len(Y_protein)
Y_alcohol_avg = sum(Y_alcohol)/len(Y_alcohol)
Y_caffeine_avg = sum(Y_caffeine)/len(Y_caffeine)
p1 = (Y_carb[5]-Y_carb_avg)*100/Y_carb_avg
p2 = (Y_protein[5]-Y_protein_avg)*100/Y_protein_avg
p3 = (Y_alcohol[5]-Y_alcohol_avg)*100/Y_alcohol_avg
p4 = (Y_caffeine[5]-Y_caffeine_avg)*100/Y_caffeine_avg
p_friday = (Y_carb[5] + Y_protein[5]+Y_alcohol[5]+Y_caffeine[5])
p_overall_avg1 = (sum(Y_carb) + sum(Y_protein)+sum(Y_alcohol)+sum(Y_caffeine))/len(Y_carb)
print("Nutrients intake on friday")
print(p_friday)
print("Average intake for all days")
print(p_overall_avg1)
print("percentage increment of friday intake")
print((p_friday- p_overall_avg1)*100/p_overall_avg1)

import numpy as np 
import matplotlib.pyplot as plt 
  
X = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
  
X_axis = np.arange(len(X))
colors = [plt.get_cmap('BrBG')(0.25), 'grey'] + [plt.get_cmap('BrBG')(0.25)] * 7

plt.bar(X_axis - 0.2, Y_protein, 0.1, label = 'Proteins',color = colors[0])
plt.bar(X_axis - 0.1, Y_carb, 0.1, label = 'Carbs',color = 'brown')
plt.bar(X_axis , Y_caffeine, 0.1, label = 'Caffeine',color = "black")
plt.bar(X_axis+0.1 , Y_alcohol, 0.1, label = 'Alcohol',color = 'orange')
plt.rcParams['figure.dpi'] = 100
plt.rcParams['savefig.dpi'] = 100

plt.xticks(X_axis, X,rotation=45)
plt.xlabel(" Intake day of the week")
plt.ylabel("Quantity (gms)")
plt.title("Consumption to the intake day of the week")
plt.legend()
plt.show()

#verified the covariance coefficient of Alcohol
import statistics
import math
for j in df_nutritions["DR1TALCO"]:
  if(j>0.03):
   print(j)
# c1 = [if(j>0.03) for j in df_nutritions["DR1TALCO"]:]
v= statistics.variance(df_nutritions["DR1TALCO"])
s = math.sqrt(v)
m = statistics.mean(df_nutritions["DR1TALCO"])

#skewness coefiicient  and plot of alcohol
from scipy.stats import skew
print(skew(df_nutritions["DR1TALCO"],bias=False))
from scipy.stats import skew
import numpy as np 
import pylab as p 
  
x1 = df_nutritions['SEQN']
y1 = df_nutritions['DR1TALCO']
  
p.plot(x1, y1, '*')
  
print( '\nSkewness for data : ', skew(y1))

# spliiting teh columns names to categorical variables and continuous variables
binary_df_columns = []
teritionary_df_columns = []
constant_df_columns = []
continuous_variables=[]
all_categorical_columns =[]

for h in df_nutritions.columns:
  d = set(df_nutritions[h])
  if(len(d)==2):
    all_categorical_columns.append(h)
    binary_df_columns.append(h)
  elif(len(d)<=5 and len(d)>2):
    all_categorical_columns.append(h)
    teritionary_df_columns.append(h)
  elif(len(d)==1):
    constant_df_columns.append(h)
  else:
    continuous_variables.append(h)

#Continuous variables analysis
df_continuous_variables_all = df_nutritions[continuous_variables]
df_continuous_variables_labels = ["Folate", "Sodium", "Total monounsaturated fatty acids", "Vitamin A, RAE", "Phosphorus", "Alcohol", "Energy (kcal)"]
df_continuous_variables = ["DR1TFDFE", "DR1TSODI", "DR1TMFAT", "DR1TVARA", "DR1TPHOS" ,"DR1TALCO","DR1TKCAL"]
df_continuous_variables_labels_gms = ["Carbohydrate", "Total sugars", "Dietary fiber", "Moisture","Magnesium", "Caffeine", "Alcohol"]
df_continuous_variables_gms = ["DR1TCARB", "DR1TSUGR", "DR1TFIBE", "DR1TMOIS", "DR1TMAGN","DR1TCAFF","DR1TALCO","DR1TSODI"]
df_continuous_variables = df_nutritions[df_continuous_variables]
df_continuous_variables_gm1 = df_nutritions[df_continuous_variables_gms[:2]]
df_continuous_variables_gm1 =df_continuous_variables_gm1 
df_continuous_variables_gm2 = df_nutritions[df_continuous_variables_gms[2:]]
df_continuous_variables_gm2 =df_continuous_variables_gm2*0.001
df_continuous_variables_gm = [df_continuous_variables_gm1,df_continuous_variables_gm2]
result = pd.concat(df_continuous_variables_gm, axis=1)

#getting the highly correlated values
df_nutritions
df_corr = df_nutritions[continuous_variables].corr()
np.fill_diagonal(df_corr.values, 0)
df_corr.style.highlight_max(color='yellow').highlight_min(color='blue')
sorted_mat = df_corr.unstack().sort_values()
sorted_mat.iloc[3::30]

result = df_nutritions
import matplotlib.pyplot as plt
import numpy as np
final =[]
total_values = sum(result["DR1TMAGN"])+sum(result["DR1TCARB"])+sum(result["DR1TMOIS"])+sum(result["DR1TCAFF"])+sum(result["DR1TSUGR"])+sum(result["DR1TALCO"])+sum(result["DR1TSODI"])+sum(result["DR1TFIBE"])
final.append(100*sum(result["DR1TMAGN"])/total_values)
final.append(100*sum(result["DR1TCARB"])/total_values)
final.append(100*sum(result["DR1TMOIS"])/total_values)
final.append(100*sum(result["DR1TCAFF"])/total_values)
final.append(100*sum(result["DR1TSUGR"])/total_values)
final.append(100*sum(result["DR1TALCO"])/total_values)
final.append(100*sum(result["DR1TSODI"])/total_values)
final.append(100*sum(result["DR1TFIBE"])/total_values)
y = np.array(final)
colors_grey = [plt.get_cmap('BrBG')(0.25), 'grey'] + [plt.get_cmap('BrBG')(0.25)] * 7
colors = ["red", colors_grey[0], "black", "#4CAF50","orange","orange","blue","magenta"]
df_continuous_variables_labels_gms = ["Magnesium","Carbohydrate", "Moisture", "Caffeine","Total sugars","Alcohol","Sodium", "Dietary fiber"]

#caries to the sugars
import matplotlib.pyplot as plt
import seaborn as sns
df_data =df_data[0:10000]
print(df_dental.columns)
df_corr = df_data[['POSTERIOR_TOOTH_COUNT', 'POSTERIOR_CARIES_COUNT'
       ,'DR1TSUGR']].corr()
ax = sns.heatmap(df_corr, annot=True, fmt=".3f")
plt.xticks(rotation = 70)

import matplotlib.pyplot as plot
sns.set_style("whitegrid")
df_continuous_variables_labels_gms = ["Carbohydrate", "Total sugars", "Dietary fiber", "Moisture","Magnesium", "Caffeine", "Alcohol","Sodium"]
df_continuous_variables_gms = ["DR1TCARB", "DR1TSUGR", "DR1TFIBE", "DR1TMOIS", "DR1TMAGN","DR1TCAFF","DR1TALCO","DR1TSODI"]

result.rename(columns = {'DR1TCARB' : 'Carbohydrate', 'DR1TSUGR' : 'Total sugars',"DR1TFIBE":" Dietary fiber"}, inplace = True)
result = result[:10000]
print(result.columns)
a= ['Carbohydrate', 'Total sugars']
ax = sns.boxplot( data = result)
ax.set(xlabel="", ylabel="")
ax.xaxis.tick_top()
plt.ylabel("Amount (gms)")
plot.show()
import matplotlib.pyplot as plot
sns.set_style("whitegrid")
  
sns.boxplot( data = result[:-4])
ax.set_yticklabels(df_continuous_variables_labels_gms[2:])
plt.title("Nutritional attributes box plot")
plot.show()

#box plots of alcohol
import matplotlib.pyplot as plot
sns.set_style("whitegrid")
result = result[:10000]
print(result.columns)
a= ['DR1TALCO']
ax = sns.boxplot( data = result[a])
ax.set(xlabel="", ylabel="")
ax.xaxis.tick_top()
plt.ylabel("Amount (gms)")
plot.show()

#plotting second outlierrs plot
import matplotlib.pyplot as plot
sns.set_style("whitegrid")
df_continuous_variables_labels_gms = ["Carbohydrate", "Total sugars", "Dietary fiber", "Moisture","Magnesium", "Caffeine", "Alcohol","Sodium"]
df_continuous_variables_gms = ["DR1TCARB", "DR1TSUGR", "DR1TFIBE", "DR1TMOIS", "DR1TMAGN","DR1TCAFF","DR1TALCO","DR1TSODI"]
# a = ["Carbohydrate", "DR1TSUGR"]

result.rename(columns = {'DR1TFIBE' : 'Dietary fiber', 'DR1TMOIS' : 'Moisture',"DR1TMAGN":" Magnesium", "DR1TCAFF":"Caffeine","DR1TALCO":"Alcohol","DR1TSODI":"Sodium"}, inplace = True)
# result.columns = result.columns.str.replace(df_continuous_variables_labels_gms)
result = result[:300]
print(result.columns)
a= [' Dietary fiber', 'Moisture',' Magnesium', 'Caffeine', 'Alcohol', 'Sodium']
ax = sns.boxplot( data = result[a])
ax.set(xlabel="", ylabel="")
ax.xaxis.tick_top()
plt.ylabel("Amount (gms)")
plot.show()

df_corr = df_continuous_variables.corr()
np.fill_diagonal(df_corr.values, 0)
df_corr.style.highlight_max(color='yellow').highlight_min(color='blue')